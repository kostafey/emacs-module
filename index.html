<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2017-09-07 Thu 02:05 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Writing Emacs modules with Go</title>
<meta name="generator" content="Org mode" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/ >
<link rel="stylesheet" media="screen" href="https://fontlibrary.org/face/go-mono" type="text/css"/>
<link href="https://fonts.googleapis.com/css?family=Cabin+Sketch" rel="stylesheet"/>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.100.2/css/materialize.min.css"/>
<link href="layout.css" rel="stylesheet"/>
<script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.100.2/js/materialize.min.js"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2017 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Writing Emacs modules with Go</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org18d5fd2">1. Introduction</a></li>
<li><a href="#orgd5798bb">2. C Emacs module</a></li>
<li><a href="#org9534ed4">3. Go Emacs Module</a></li>
<li><a href="#orga0f31af">4. Automating this guide.</a></li>
<li><a href="#org6b9a92a">5. Todo's</a></li>
</ul>
</div>
</div>
<p width="40px">
<img src="img/org-mode-unicorn-logo_2017-09-05_10-16-22.png" alt="org-mode-unicorn-logo_2017-09-05_10-16-22.png" width="40px" />This page is generated using <code>(org-html-export-to-html)</code> if you prefer using
<code>org-mode</code> you can get the org file from<a href="https://raw.githubusercontent.com/mrosset/emacs-module/master/index.org"> GitHub</a>.
</p>

<div id="outline-container-org18d5fd2" class="outline-2">
<h2 id="org18d5fd2"><span class="section-number-2">1</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
This page is currently complete, but should still be concidered a draft. If you
find any grammar, spelling or technical errors. Please create an issue on <a href="https://github.com/mrosset/emacs-module">GitHub</a>
</p>

<p>
As of Emacs version <code>25.1</code> Emacs has support for loading dynamic modules. And as
of version <code>1.5</code> Go supports building packages as dynamic shared libraries.
Allowing us to write Emacs functions in Go. This guide will walk you through
creating first a simple module in C and then a simple module in Go. There is not
a huge difference between the two. But understanding the C module well help when
we write our Go module.
</p>
</div>
</div>

<div id="outline-container-orgd5798bb" class="outline-2">
<h2 id="orgd5798bb"><span class="section-number-2">2</span> C Emacs module</h2>
<div class="outline-text-2" id="text-2">
<p>
First create a top level directory to house our project . I like to create my
projects in <code>$HOME/src</code> pick whichever location suits you. Once we
create the directory we'll <code>cd</code> into it. And any commands we run from now on.
Will be from that directory.
</p>

<div class="org-src-container">
<pre class="src src-shell">mkdir -pv ~/src/emacs-module
<span class="org-builtin">cd</span> ~/src/emacs-module
</pre>
</div>

<p>
To compile a Emacs modules we need the <code>emacs-module.h</code> header file. The header
file is found in the <code>src</code> directory of the Emacs source tarball. It's possible your
OS provides this already. However this guide is OS agnostic and we'll assume
that the header file has not been installed. Since we just need the header and
not all of the emacs tarball we'll download it from the git repository.
</p>

<p>
Create the src directory
</p>
<div class="org-src-container">
<pre class="src src-shell">mkdir src
</pre>
</div>

<p>
Download the emacs header file
</p>
<div class="org-src-container">
<pre class="src src-shell">wget <span class="org-string">"http://git.savannah.gnu.org/cgit/emacs.git/plain/src/emacs-module.h?h=emacs-25.2"</span> -O src/emacs-module.h
</pre>
</div>
</div>

<div id="outline-container-orgf04c816" class="outline-3">
<h3 id="orgf04c816"><span class="section-number-3">2.1</span> <code>src/cmodule.c</code></h3>
<div class="outline-text-3" id="text-2-1">
<p>
If you are using <code>org-mode</code> you can generate this file automatically with <code>C-c C-v
t</code> or <code>M-x org-babel-tangle</code> .
</p>

<p>
Here is the complete C file. In the next section we'll do a line by line breakdown
of what it does.
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">emacs-module.h</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">stdio.h</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-preprocessor">#define</span> <span class="org-variable-name">CMOD_VERSION</span>  <span class="org-string">"0.1"</span>

<span class="org-type">int</span> <span class="org-variable-name">plugin_is_GPL_compatible</span>;

<span class="org-keyword">static</span> <span class="org-type">emacs_value</span>
<span class="org-function-name">Fcmodule_version</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">emacs_env</span> * <span class="org-variable-name">env</span>, <span class="org-type">ptrdiff_t</span> <span class="org-variable-name">nargs</span>, <span class="org-type">emacs_value</span> <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-2">[]</span>,
      <span class="org-type">void</span> *<span class="org-variable-name">data</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">return</span> env-&gt;make_string <span class="org-rainbow-delimiters-depth-2">(</span>env, CMOD_VERSION, <span class="org-highlight-numbers-number">3</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-keyword">extern</span>
<span class="org-type">int</span> <span class="org-function-name">emacs_module_init</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">struct</span> <span class="org-type">emacs_runtime</span> *<span class="org-variable-name">ert</span><span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-type">emacs_env</span> *<span class="org-variable-name">env</span> = ert-&gt;get_environment <span class="org-rainbow-delimiters-depth-2">(</span>ert<span class="org-rainbow-delimiters-depth-2">)</span>;

<span class="org-type">emacs_value</span> <span class="org-variable-name">Qfeat</span> = env-&gt;intern <span class="org-rainbow-delimiters-depth-2">(</span>env, <span class="org-string">"cmodule"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-type">emacs_value</span> <span class="org-variable-name">Qprovide</span> = env-&gt;intern <span class="org-rainbow-delimiters-depth-2">(</span>env, <span class="org-string">"provide"</span><span class="org-rainbow-delimiters-depth-2">)</span>;

<span class="org-type">emacs_value</span> <span class="org-variable-name">pargs</span><span class="org-rainbow-delimiters-depth-2">[]</span> = <span class="org-rainbow-delimiters-depth-2">{</span> Qfeat <span class="org-rainbow-delimiters-depth-2">}</span>;
env-&gt;funcall <span class="org-rainbow-delimiters-depth-2">(</span>env, Qprovide, <span class="org-highlight-numbers-number">1</span>, pargs<span class="org-rainbow-delimiters-depth-2">)</span>;

<span class="org-type">emacs_value</span> <span class="org-variable-name">fn</span> = env-&gt;make_function <span class="org-rainbow-delimiters-depth-2">(</span>env, <span class="org-highlight-numbers-number">0</span>, <span class="org-highlight-numbers-number">0</span>, Fcmodule_version,
                 <span class="org-string">"Returns cmodule version"</span>, <span class="org-constant">NULL</span><span class="org-rainbow-delimiters-depth-2">)</span>;

<span class="org-type">emacs_value</span> <span class="org-variable-name">Qfset</span> = env-&gt;intern <span class="org-rainbow-delimiters-depth-2">(</span>env, <span class="org-string">"fset"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-type">emacs_value</span> <span class="org-variable-name">Qsym</span> = env-&gt;intern <span class="org-rainbow-delimiters-depth-2">(</span>env, <span class="org-string">"cmodule-version"</span><span class="org-rainbow-delimiters-depth-2">)</span>;

<span class="org-type">emacs_value</span> <span class="org-variable-name">fargs</span><span class="org-rainbow-delimiters-depth-2">[]</span> = <span class="org-rainbow-delimiters-depth-2">{</span> Qsym, fn <span class="org-rainbow-delimiters-depth-2">}</span>;
env-&gt;funcall<span class="org-rainbow-delimiters-depth-2">(</span>env, Qfset, <span class="org-highlight-numbers-number">2</span>, fargs<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgcffa5b2" class="outline-3">
<h3 id="orgcffa5b2"><span class="section-number-3">2.2</span> C Breakdown</h3>
<div class="outline-text-3" id="text-2-2">
<p>
First we include <code>emacs-module.h</code> header file. We'll need this for the Emacs
declaration types.
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">emacs-module.h</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>
<span class="org-preprocessor">#include</span> <span class="org-string"><span class="org-rainbow-delimiters-depth-1">&lt;</span></span><span class="org-string">stdio.h</span><span class="org-string"><span class="org-rainbow-delimiters-depth-1">&gt;</span></span>

<span class="org-preprocessor">#define</span> <span class="org-variable-name">CMOD_VERSION</span>  <span class="org-string">"0.1"</span>
</pre>
</div>

<p>
Emacs also requires a <code>plugin_is_GPL_compatible</code> symbol, if not declared then
Emacs will not load the module.
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-type">int</span> <span class="org-variable-name">plugin_is_GPL_compatible</span>;
</pre>
</div>

<p>
Next is the C function that we plan to call from Emacs. Our function is
simple, all it does is take a C string literal called <code>CMOD_VERSION</code>. Creates an
Emacs string and then returns it.
</p>

<div class="org-src-container">
<pre class="src src-C"><span class="org-keyword">static</span> <span class="org-type">emacs_value</span>
<span class="org-function-name">Fcmodule_version</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-type">emacs_env</span> * <span class="org-variable-name">env</span>, <span class="org-type">ptrdiff_t</span> <span class="org-variable-name">nargs</span>, <span class="org-type">emacs_value</span> <span class="org-variable-name">args</span><span class="org-rainbow-delimiters-depth-2">[]</span>,
      <span class="org-type">void</span> *<span class="org-variable-name">data</span><span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">return</span> env-&gt;make_string <span class="org-rainbow-delimiters-depth-2">(</span>env, CMOD_VERSION, <span class="org-highlight-numbers-number">3</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Next is the entry point of our module and is run when the module is first
loaded by Emacs.
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-keyword">extern</span>
<span class="org-type">int</span> <span class="org-function-name">emacs_module_init</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">struct</span> <span class="org-type">emacs_runtime</span> *<span class="org-variable-name">ert</span><span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
First we get the Emacs environment from the Emacs run-time.
</p>
<div class="org-src-container">
<pre class="src src-C"><span class="org-rainbow-delimiters-depth-1">{</span>
<span class="org-type">emacs_env</span> *<span class="org-variable-name">env</span> = ert-&gt;get_environment <span class="org-rainbow-delimiters-depth-2">(</span>ert<span class="org-rainbow-delimiters-depth-2">)</span>;
</pre>
</div>

<p>
We need to provision the module. We'll call the elisp <code>(provide)</code> function
through the C interface. If not Emacs will error with feature not provided.
</p>

<p>
We convert our feature string into a qouted lisp symbol. The nameing is important
our module will be compiled to <code>cmodule.so</code> so the feature symbol <b>must</b> be named <code>cmodule</code>,
anything else will not work. Then we get a quoted symbol for the elisp provide function.
</p>

<div class="org-src-container">
<pre class="src src-C"><span class="org-type">emacs_value</span> <span class="org-variable-name">Qfeat</span> = env-&gt;intern <span class="org-rainbow-delimiters-depth-1">(</span>env, <span class="org-string">"cmodule"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-type">emacs_value</span> <span class="org-variable-name">Qprovide</span> = env-&gt;intern <span class="org-rainbow-delimiters-depth-1">(</span>env, <span class="org-string">"provide"</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-type">emacs_value</span> <span class="org-variable-name">pargs</span><span class="org-rainbow-delimiters-depth-1">[]</span> = <span class="org-rainbow-delimiters-depth-1">{</span> Qfeat <span class="org-rainbow-delimiters-depth-1">}</span>;
env-&gt;funcall <span class="org-rainbow-delimiters-depth-1">(</span>env, Qprovide, <span class="org-highlight-numbers-number">1</span>, pargs<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
Next we declare our function and then use Emacs fset to define it. In short we
are telling Emacs that whenever we call <code>(cmodule-verion)</code> to execute
the <code>Fcmodule_version</code> C function.
</p>

<div class="org-src-container">
<pre class="src src-C"><span class="org-type">emacs_value</span> <span class="org-variable-name">fn</span> = env-&gt;make_function <span class="org-rainbow-delimiters-depth-1">(</span>env, <span class="org-highlight-numbers-number">0</span>, <span class="org-highlight-numbers-number">0</span>, Fcmodule_version,
                 <span class="org-string">"Returns cmodule version"</span>, <span class="org-constant">NULL</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-type">emacs_value</span> <span class="org-variable-name">Qfset</span> = env-&gt;intern <span class="org-rainbow-delimiters-depth-1">(</span>env, <span class="org-string">"fset"</span><span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-type">emacs_value</span> <span class="org-variable-name">Qsym</span> = env-&gt;intern <span class="org-rainbow-delimiters-depth-1">(</span>env, <span class="org-string">"cmodule-version"</span><span class="org-rainbow-delimiters-depth-1">)</span>;

<span class="org-type">emacs_value</span> <span class="org-variable-name">fargs</span><span class="org-rainbow-delimiters-depth-1">[]</span> = <span class="org-rainbow-delimiters-depth-1">{</span> Qsym, fn <span class="org-rainbow-delimiters-depth-1">}</span>;
env-&gt;funcall<span class="org-rainbow-delimiters-depth-1">(</span>env, Qfset, <span class="org-highlight-numbers-number">2</span>, fargs<span class="org-rainbow-delimiters-depth-1">)</span>;
<span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>;
<span class="org-rainbow-delimiters-unmatched">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org602877f" class="outline-3">
<h3 id="org602877f"><span class="section-number-3">2.3</span> Compiling the module</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Create a lib directory to hold our shared libraries.
</p>
<div class="org-src-container">
<pre class="src src-shell">mkdir -p lib
</pre>
</div>

<p>
Now we compile <code>src/cmodule.c</code> as a shared C library.
</p>
<div class="org-src-container">
<pre class="src src-shell">gcc -I src -fPIC -shared src/cmodule.c -o lib/cmodule.so
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb41a5f6" class="outline-3">
<h3 id="orgb41a5f6"><span class="section-number-3">2.4</span> Testing C module with Emacs.</h3>
<div class="outline-text-3" id="text-2-4">
<p>
To test our module we'll start Emacs in batch mode then call our custom function.
We'll use Emacs message function to print the value to stdout.
</p>
<div class="org-src-container">
<pre class="src src-bash">emacs -Q -L ./lib -batch -l cmodule --eval <span class="org-string">"(message (cmodule-version))"</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org821f016" class="outline-3">
<h3 id="org821f016"><span class="section-number-3">2.5</span> C summary</h3>
<div class="outline-text-3" id="text-2-5">
<p>
Writing a Emacs module in C is straight forward. These are the basic things you
need to create a Emacs module.
</p>

<ol class="org-ol">
<li>emacs-module.h</li>
<li>plugin<sub>is</sub><sub>GPL</sub><sub>compatibe</sub> symbol</li>
<li>emacs<sub>module</sub><sub>init</sub> entry point</li>
<li>Provision module feature within Emacs</li>
<li>fset function within Emacs</li>
</ol>

<p>
This C example was put together from <a href="http://diobla.info/blog-archive/modules-tut.html">diobla.info blog</a> . He does a good job of
breaking things down, and has some helper functions for binding and
provisioning.
</p>

<p>
Here is some additional links if your looking to create some more advanced C
module.
</p>

<ol class="org-ol">
<li><a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Dynamic-Modules.html">Dynamic Modules - GNU Emacs Lisp Reference Manual</a></li>
<li><a href="https://github.com/jkitchin/emacs-modules"><a href="https://github.com/jkitchin/emacs-modules">https://github.com/jkitchin/emacs-modules</a></a></li>
</ol>
</div>
</div>
</div>

<div id="outline-container-org9534ed4" class="outline-2">
<h2 id="org9534ed4"><span class="section-number-2">3</span> Go Emacs Module</h2>
<div class="outline-text-2" id="text-3">
<p>
We'll now make a similar module, but this time we'll access the Go runtime and
get the version of go we are using. We'll have to do some boiler plating and some C
type conversions but we can for the most part stick to go.
</p>
</div>

<div id="outline-container-orgead9075" class="outline-3">
<h3 id="orgead9075"><span class="section-number-3">3.1</span> <code>src/main.go</code></h3>
<div class="outline-text-3" id="text-3-1">
<p>
Create and edit file <code>src/main.go</code>. We'll do a breakdown of this file in the
next section.
</p>
<div class="org-src-container">
<pre class="src src-go"><span class="org-keyword">package</span> main

<span class="org-comment-delimiter">/*</span>
<span class="org-comment">#include &lt;emacs-module.h&gt;</span>
<span class="org-comment">#include &lt;stdlib.h&gt;</span>
<span class="org-comment">int plugin_is_GPL_compatible;</span>

<span class="org-comment">static void</span>
<span class="org-comment">provide (struct emacs_runtime *ert, const char *feature)</span>
<span class="org-comment">{</span>
<span class="org-comment">  emacs_env *env = ert-&gt;get_environment (ert);</span>

<span class="org-comment">  emacs_value Qfeat = env-&gt;intern (env, feature);</span>
<span class="org-comment">  emacs_value Qprovide = env-&gt;intern (env, "provide");</span>
<span class="org-comment">  emacs_value args[] = { Qfeat };</span>

<span class="org-comment">  env-&gt;funcall (env, Qprovide, 1, args);</span>
<span class="org-comment">}</span>

<span class="org-comment">extern emacs_value Fgo_version(emacs_env* p0);</span>

<span class="org-comment">static void</span>
<span class="org-comment">fset (struct emacs_runtime *ert, const char *name, void *fn)</span>
<span class="org-comment">{</span>
<span class="org-comment">  emacs_env *env = ert-&gt;get_environment (ert);</span>

<span class="org-comment">  emacs_value Qfn = env-&gt;make_function (env, 0, 0, fn,</span>
<span class="org-comment">          "Return string describing the go runtime version.", NULL);</span>

<span class="org-comment">  emacs_value Qfset = env-&gt;intern (env, "fset");</span>
<span class="org-comment">  emacs_value Qsym = env-&gt;intern (env, name);</span>

<span class="org-comment">  emacs_value fargs[] = { Qsym, Qfn };</span>
<span class="org-comment">  env-&gt;funcall (env, Qfset, 2, fargs);</span>
<span class="org-comment">}</span>

<span class="org-comment">static emacs_value</span>
<span class="org-comment">make_string (emacs_env * env, const char *s)</span>
<span class="org-comment">{</span>
<span class="org-comment">  return env-&gt;make_string (env, s, strlen(s));</span>
<span class="org-comment">}</span>

<span class="org-comment">*/</span>
<span class="org-keyword">import</span> <span class="org-string">"C"</span>
<span class="org-keyword">import</span> <span class="org-rainbow-delimiters-depth-1">(</span>
       <span class="org-string">"runtime"</span>
       <span class="org-string">"unsafe"</span>
<span class="org-rainbow-delimiters-depth-1">)</span>

<span class="org-keyword">func</span> <span class="org-function-name">freeString</span><span class="org-rainbow-delimiters-depth-1">(</span>cstring *<span class="org-type">C.char</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  C.<span class="org-function-name">free</span><span class="org-rainbow-delimiters-depth-2">(</span>unsafe.<span class="org-function-name">Pointer</span><span class="org-rainbow-delimiters-depth-3">(</span>cstring<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">//</span><span class="org-comment">export Fgo_version</span>
<span class="org-keyword">func</span> <span class="org-function-name">Fgo_version</span><span class="org-rainbow-delimiters-depth-1">(</span>env *<span class="org-type">C.emacs_env</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-type">C.emacs_value</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  version := runtime.<span class="org-function-name">Version</span><span class="org-rainbow-delimiters-depth-2">()</span>
  cversion := C.<span class="org-function-name">CString</span><span class="org-rainbow-delimiters-depth-2">(</span>version<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-keyword">defer</span> <span class="org-function-name">freeString</span><span class="org-rainbow-delimiters-depth-2">(</span>cversion<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-keyword">return</span> C.<span class="org-function-name">make_string</span><span class="org-rainbow-delimiters-depth-2">(</span>env, cversion<span class="org-rainbow-delimiters-depth-2">)</span>
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-comment-delimiter">//</span><span class="org-comment">export emacs_module_init</span>
<span class="org-keyword">func</span> <span class="org-function-name">emacs_module_init</span><span class="org-rainbow-delimiters-depth-1">(</span>ert *<span class="org-type">C.struct_emacs_runtime</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-type">C.int</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  cfeat := C.<span class="org-function-name">CString</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"gmodule"</span><span class="org-rainbow-delimiters-depth-2">)</span>
  fname := C.<span class="org-function-name">CString</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"go-version"</span><span class="org-rainbow-delimiters-depth-2">)</span>

  <span class="org-keyword">defer</span> <span class="org-function-name">freeString</span><span class="org-rainbow-delimiters-depth-2">(</span>fname<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-keyword">defer</span> <span class="org-function-name">freeString</span><span class="org-rainbow-delimiters-depth-2">(</span>cfeat<span class="org-rainbow-delimiters-depth-2">)</span>

  C.<span class="org-function-name">provide</span><span class="org-rainbow-delimiters-depth-2">(</span>ert, cfeat<span class="org-rainbow-delimiters-depth-2">)</span>
  C.<span class="org-function-name">fset</span><span class="org-rainbow-delimiters-depth-2">(</span>ert, fname, C.Fgo_version<span class="org-rainbow-delimiters-depth-2">)</span>;
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>
<span class="org-rainbow-delimiters-depth-1">}</span>

<span class="org-keyword">func</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orga026bff" class="outline-3">
<h3 id="orga026bff"><span class="section-number-3">3.2</span> Go Breakdown</h3>
<div class="outline-text-3" id="text-3-2">
<p>
We'll name our package main, even though we are not creating a command module
it's important the package name is main, otherwise when we build a c-shared
library it will build an ar archive, and not a dynamic library.
</p>

<div class="org-src-container">
<pre class="src src-go"><span class="org-keyword">package</span> main
</pre>
</div>

<p>
And in the comments section we include <code>emacs-module.h</code> . We also
declare <code>int plugin_is_GPL_compatible</code>.
</p>

<div class="org-src-container">
<pre class="src src-go"><span class="org-comment-delimiter">/*</span>
<span class="org-comment">#include &lt;emacs-module.h&gt;</span>
<span class="org-comment">#include &lt;stdlib.h&gt;</span>
<span class="org-comment">int plugin_is_GPL_compatible;</span>
</pre>
</div>

<p>
We need to provision our feature within emacs. To do this we need to call the
Emacs <code>(provide)</code> function just like we did with the C module. Unfortunately we
can not call C pointer functions directly from Go. But we can call them from C.
So we'll create a helper C function that can access the struct function pointer we
need. We'll do this in the special comment section just before <code>import "C"</code>.
</p>
<div class="org-src-container">
<pre class="src src-go">static void
<span class="org-function-name">provide</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">struct</span> emacs_runtime *ert, <span class="org-keyword">const</span> char *feature<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
  emacs_env *env = ert-&gt;<span class="org-function-name">get_environment</span> <span class="org-rainbow-delimiters-depth-2">(</span>ert<span class="org-rainbow-delimiters-depth-2">)</span>;

  emacs_value Qfeat = env-&gt;<span class="org-function-name">intern</span> <span class="org-rainbow-delimiters-depth-2">(</span>env, feature<span class="org-rainbow-delimiters-depth-2">)</span>;
  emacs_value Qprovide = env-&gt;<span class="org-function-name">intern</span> <span class="org-rainbow-delimiters-depth-2">(</span>env, <span class="org-string">"provide"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
  emacs_value args<span class="org-rainbow-delimiters-depth-2">[]</span> = <span class="org-rainbow-delimiters-depth-2">{</span> Qfeat <span class="org-rainbow-delimiters-depth-2">}</span>;

  env-&gt;<span class="org-function-name">funcall</span> <span class="org-rainbow-delimiters-depth-2">(</span>env, Qprovide, <span class="org-highlight-numbers-number">1</span>, args<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
We declare our function in C even though cgo will generate a <code>gmodule.h</code> file. If
we don't declare it now we won't be able to reference it from this file.
</p>
<div class="org-src-container">
<pre class="src src-go">extern emacs_value <span class="org-function-name">Fgo_version</span><span class="org-rainbow-delimiters-depth-1">(</span>emacs_env* p0<span class="org-rainbow-delimiters-depth-1">)</span>;
</pre>
</div>

<p>
We create a helper function to fset our function within emacs, this function
assumes our Emacs function will not be taking any arguements it's not ideal but
it will work for the function we want to create. We also hardcode our doc
</p>
<div class="org-src-container">
<pre class="src src-go">static void
<span class="org-function-name">fset</span> <span class="org-rainbow-delimiters-depth-1">(</span><span class="org-keyword">struct</span> emacs_runtime *ert, <span class="org-keyword">const</span> char *name, void *fn<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
  emacs_env *env = ert-&gt;<span class="org-function-name">get_environment</span> <span class="org-rainbow-delimiters-depth-2">(</span>ert<span class="org-rainbow-delimiters-depth-2">)</span>;

  emacs_value Qfn = env-&gt;<span class="org-function-name">make_function</span> <span class="org-rainbow-delimiters-depth-2">(</span>env, <span class="org-highlight-numbers-number">0</span>, <span class="org-highlight-numbers-number">0</span>, fn,
          <span class="org-string">"Return string describing the go runtime version."</span>, NULL<span class="org-rainbow-delimiters-depth-2">)</span>;

  emacs_value Qfset = env-&gt;<span class="org-function-name">intern</span> <span class="org-rainbow-delimiters-depth-2">(</span>env, <span class="org-string">"fset"</span><span class="org-rainbow-delimiters-depth-2">)</span>;
  emacs_value Qsym = env-&gt;<span class="org-function-name">intern</span> <span class="org-rainbow-delimiters-depth-2">(</span>env, name<span class="org-rainbow-delimiters-depth-2">)</span>;

  emacs_value fargs<span class="org-rainbow-delimiters-depth-2">[]</span> = <span class="org-rainbow-delimiters-depth-2">{</span> Qsym, Qfn <span class="org-rainbow-delimiters-depth-2">}</span>;
  env-&gt;<span class="org-function-name">funcall</span> <span class="org-rainbow-delimiters-depth-2">(</span>env, Qfset, <span class="org-highlight-numbers-number">2</span>, fargs<span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Later on we'll need to convert the runtime version Go string into a Emacs string
value. Since we can't call function pointers directly we'll create a helper
function to handle this.
</p>
<div class="org-src-container">
<pre class="src src-go">static emacs_value
<span class="org-function-name">make_string</span> <span class="org-rainbow-delimiters-depth-1">(</span>emacs_env * env, <span class="org-keyword">const</span> char *s<span class="org-rainbow-delimiters-depth-1">)</span>
<span class="org-rainbow-delimiters-depth-1">{</span>
  <span class="org-keyword">return</span> env-&gt;<span class="org-function-name">make_string</span> <span class="org-rainbow-delimiters-depth-2">(</span>env, s, <span class="org-function-name">strlen</span><span class="org-rainbow-delimiters-depth-3">(</span>s<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>;
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
We need to import the C package. The C package is special since it tells go to
build with cgo. It's important that this package import comes first and it on
it's own line. We need to close our C comment section just before <code>import "C"</code>
there should be no new lines after closing the comment.
</p>
<div class="org-src-container">
<pre class="src src-go">*/
<span class="org-keyword">import</span> <span class="org-string">"C"</span>
<span class="org-keyword">import</span> <span class="org-rainbow-delimiters-depth-1">(</span>
       <span class="org-string">"runtime"</span>
       <span class="org-string">"unsafe"</span>
<span class="org-rainbow-delimiters-depth-1">)</span>
</pre>
</div>

<p>
We'll be using some C strings. Go will not be able to memory manage our C
types. so we'll have to use some unsafe functions and free the strings
ourselves. We'll create a <code>freeString</code> function to make this easier. <code>C.free</code> calls the
free function  we included in <code>stdlib.h</code>. We also need to use the unsafe package
to get the pointer.
</p>
<div class="org-src-container">
<pre class="src src-go"><span class="org-keyword">func</span> <span class="org-function-name">freeString</span><span class="org-rainbow-delimiters-depth-1">(</span>cstring *<span class="org-type">C.char</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  C.<span class="org-function-name">free</span><span class="org-rainbow-delimiters-depth-2">(</span>unsafe.<span class="org-function-name">Pointer</span><span class="org-rainbow-delimiters-depth-3">(</span>cstring<span class="org-rainbow-delimiters-depth-3">)</span><span class="org-rainbow-delimiters-depth-2">)</span>
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
We declare the Go function. This is the Go code that will be exectuted when we
call our Emacs function using <code>(go-version)</code> . Our function will return a type
that emacs can evaluate. In this case the go runtime version as a string.
</p>

<div class="org-src-container">
<pre class="src src-go"><span class="org-comment-delimiter">//</span><span class="org-comment">export Fgo_version</span>
<span class="org-keyword">func</span> <span class="org-function-name">Fgo_version</span><span class="org-rainbow-delimiters-depth-1">(</span>env *<span class="org-type">C.emacs_env</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-type">C.emacs_value</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  version := runtime.<span class="org-function-name">Version</span><span class="org-rainbow-delimiters-depth-2">()</span>
  cversion := C.<span class="org-function-name">CString</span><span class="org-rainbow-delimiters-depth-2">(</span>version<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-keyword">defer</span> <span class="org-function-name">freeString</span><span class="org-rainbow-delimiters-depth-2">(</span>cversion<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-keyword">return</span> C.<span class="org-function-name">make_string</span><span class="org-rainbow-delimiters-depth-2">(</span>env, cversion<span class="org-rainbow-delimiters-depth-2">)</span>
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>

<p>
Next we create our Emacs entry point. and we'll use <code>//export</code> directive to tell
cgo we want to export this as a dynamic function. This is the same as if we
wrote <code>extern int emacs_module_init(struct emacs_runtime* p0);</code> in C, in fact Go
will produce this declaration when it creates a C header file for our dynamic library.
</p>

<p>
If we were to return the Go type <code>int</code> instead of <code>C.int</code> it would create a
compiler error since the signature would no longer match the Emacs one.
</p>
<div class="org-src-container">
<pre class="src src-go"><span class="org-comment-delimiter">//</span><span class="org-comment">export emacs_module_init</span>
<span class="org-keyword">func</span> <span class="org-function-name">emacs_module_init</span><span class="org-rainbow-delimiters-depth-1">(</span>ert *<span class="org-type">C.struct_emacs_runtime</span><span class="org-rainbow-delimiters-depth-1">)</span> <span class="org-type">C.int</span> <span class="org-rainbow-delimiters-depth-1">{</span>
  cfeat := C.<span class="org-function-name">CString</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"gmodule"</span><span class="org-rainbow-delimiters-depth-2">)</span>
  fname := C.<span class="org-function-name">CString</span><span class="org-rainbow-delimiters-depth-2">(</span><span class="org-string">"go-version"</span><span class="org-rainbow-delimiters-depth-2">)</span>

  <span class="org-keyword">defer</span> <span class="org-function-name">freeString</span><span class="org-rainbow-delimiters-depth-2">(</span>fname<span class="org-rainbow-delimiters-depth-2">)</span>
  <span class="org-keyword">defer</span> <span class="org-function-name">freeString</span><span class="org-rainbow-delimiters-depth-2">(</span>cfeat<span class="org-rainbow-delimiters-depth-2">)</span>

  C.<span class="org-function-name">provide</span><span class="org-rainbow-delimiters-depth-2">(</span>ert, cfeat<span class="org-rainbow-delimiters-depth-2">)</span>
  C.<span class="org-function-name">fset</span><span class="org-rainbow-delimiters-depth-2">(</span>ert, fname, C.Fgo_version<span class="org-rainbow-delimiters-depth-2">)</span>;
  <span class="org-keyword">return</span> <span class="org-highlight-numbers-number">0</span>
<span class="org-rainbow-delimiters-depth-1">}</span>
</pre>
</div>


<p>
Even though this is not a command package. We need to include a main function.
Due to the fact we are exporting go functions using <code>//export</code> . We can simply
stub one out like so.
</p>
<div class="org-src-container">
<pre class="src src-go"><span class="org-keyword">func</span> <span class="org-function-name">main</span><span class="org-rainbow-delimiters-depth-1">()</span> <span class="org-rainbow-delimiters-depth-1">{}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc31e2ab" class="outline-3">
<h3 id="orgc31e2ab"><span class="section-number-3">3.3</span> Building the Go module</h3>
<div class="outline-text-3" id="text-3-3">
<p>
We export our include flags and then manually build our so file.
</p>
<div class="org-src-container">
<pre class="src src-shell">go build -buildmode=c-shared -o lib/gmodule.so src/main.go
</pre>
</div>
</div>
</div>
<div id="outline-container-org4c743a5" class="outline-3">
<h3 id="org4c743a5"><span class="section-number-3">3.4</span> Test the Go module</h3>
<div class="outline-text-3" id="text-3-4">
<div class="org-src-container">
<pre class="src src-bash">emacs -Q -L ./lib -batch -l <span class="org-string">"gmodule"</span> --eval <span class="org-string">'(message (go-version))'</span>
</pre>
</div>

<pre class="example">
go1.9

</pre>
</div>
</div>
</div>

<div id="outline-container-orga0f31af" class="outline-2">
<h2 id="orga0f31af"><span class="section-number-2">4</span> Automating this guide.</h2>
<div class="outline-text-2" id="text-4">
<p>
This whole guide can be run without any manual input using.
</p>
<pre class="example">
(org-babel-tangle)
(org-babel-execute-buffer)
</pre>
</div>
</div>
<div id="outline-container-org6b9a92a" class="outline-2">
<h2 id="org6b9a92a"><span class="section-number-2">5</span> Todo's</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-org68d08e5" class="outline-3">
<h3 id="org68d08e5"><span class="section-number-3">5.1</span> <span class="done DONE">DONE</span> emacs-module.h</h3>
<div class="outline-text-3" id="text-5-1">
<p>
The emacs tarball is pretty large. figure out how we can download the header
file and still be GPL compliant.
</p>
</div>
</div>
<div id="outline-container-org0212447" class="outline-3">
<h3 id="org0212447"><span class="section-number-3">5.2</span> <span class="todo TODO">TODO</span> GPL compliance</h3>
<div class="outline-text-3" id="text-5-2">
<p>
Find out what GPL implications might arise from writing packages in Go. Go uses
a claused BSD license not sure of hosting the go runtime within emacs breaks GPL
or not.
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2017-09-07 Thu 02:05</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
