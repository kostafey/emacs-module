# -*- org-confirm-babel-evaluate: nil; after-save-hook: tangle-and-export; org-export-in-background: t; -*-
# org-html-htmlize-output-type css;

#+EMAIL: mike.rosset@gmail.com
#+OPTIONS: toc:t num:5 H:5 ^:nil pri:nil html-style:nil

#+HTML_HEAD: <meta name="viewport" content="width=device-width, initial-scale=1.0"/ >
#+HTML_HEAD: <link rel="stylesheet" media="screen" href="https://fontlibrary.org/face/go-mono" type="text/css"/>
#+HTML_HEAD: <link href="https://fonts.googleapis.com/css?family=Cabin+Sketch" rel="stylesheet"/>
#+HTML_HEAD: <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.100.2/css/materialize.min.css"/>
#+HTML_HEAD: <link href="layout.css" rel="stylesheet"/>
#+HTML_HEAD: <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.100.2/js/materialize.min.js"/>

#+TITLE: Writing Emacs modules with Go
#+DOWNLOADED: http://orgmode.org/img/org-mode-unicorn-logo.png @ 2017-09-05 10:16:22
#+ATTR_HTML: :width 40px
[[file:img/org-mode-unicorn-logo_2017-09-05_10-16-22.png]]This page is generated using ~(org-html-export-to-html)~ if you prefer using
~org-mode~ you can get the org file from[[https://raw.githubusercontent.com/mrosset/emacs-module/master/index.org][ GitHub]].
* Introduction
:PROPERTIES:
:HTML_CONTAINER_CLASS: container
:END:

As of Emacs version ~25.1~ Emacs is able to load dynamic modules. And as of
version ~1.5~ Go supports building packages as dynamic shared libraries.
Allowing us to write Emacs functions in Go. This guide will walk you through
creating first a simple module in C and then a simple module in Go. There
is not a huge difference between the two. But understanding the C module well
help when we write our Go module.
** Minimal Emacs module in C
First create a top level directory to house our project . I like to create my
projects in ~$HOME/src~ pick which ever location suits you best. Once we
create the directory we'll ~cd~ into it. And any commands we run from now on.
Will be from that directory.

#+BEGIN_SRC shell
mkdir -pv ~/src/emacs-module
cd ~/src/emacs-module
#+END_SRC

#+RESULTS:

To compile a Emacs modules we need the ~emacs-module.h~ header file. The header
file is found in the ~src~ directory of the Emacs source tarball. It's possible your
OS provides this already. However this guide is OS agnostic and we'll assume
that the header file has not been installed.

Download the emacs source tarball.
#+BEGIN_SRC shell :results silent :dir ~/src/emacs-module
wget -c https://mirrors.kernel.org/gnu/emacs/emacs-25.2.tar.gz
#+END_SRC

And then extract it.
#+BEGIN_SRC shell :results silent :dir ~/src/emacs-module
tar xf emacs-25.2.tar.gz
#+END_SRC

Create the src directory
#+BEGIN_SRC shell :results silent :dir ~/src/emacs-module
mkdir src
#+END_SRC

** ~src/cmodule.c~

If you are using ~org-mode~ you can generate this file automatically with ~C-c C-v
t~ or ~M-x org-babel-tangle~ .

Here is the complete C file. In the next section we'll do a line by line breakdown
of what it does.
#+INCLUDE: src/cmodule.c src C

** C Breakdown
First we include ~emacs-module.h~ header file. We'll need this for the Emacs
declaration types.
#+BEGIN_SRC C :main no :tangle src/cmodule.c
#include <emacs-module.h>
#include <stdio.h>

#define CMOD_VERSION  "0.1"
#+END_SRC

#+RESULTS:

Emacs also requires a ~plugin_is_GPL_compatible~ symbol, if not declared then
Emacs will not load the module.
#+BEGIN_SRC C :main no :tangle src/cmodule.c
int plugin_is_GPL_compatible;
#+END_SRC

#+RESULTS:

Next is the C function that we plan to call from Emacs. Our function is
simple, all it does is take a C string literal called ~CMOD_VERSION~. Creates an
Emacs strings and then returns it.

#+BEGIN_SRC C :main no :tangle src/cmodule.c
  static emacs_value
  Fcmodule_version (emacs_env * env, ptrdiff_t nargs, emacs_value args[],
        void *data)
  {
    return env->make_string (env, CMOD_VERSION, 3);
  }
#+END_SRC

#+RESULTS:

Next is the entry point of our module and is run when the module is first
loaded by Emacs.
#+BEGIN_SRC C :main no :tangle src/cmodule.c
  extern
  int emacs_module_init (struct emacs_runtime *ert)
  {
#+END_SRC

#+RESULTS:

We need to provision the module. We'll call the elisp ~(provide)~ function
through the C interface. If not Emacs will error with feature not provided.

First we get the Emacs environment from the Emacs run-time.
#+BEGIN_SRC C -p :main no :tangle src/cmodule.c
emacs_env *env = ert->get_environment (ert);
#+END_SRC

#+RESULTS:

Then we convert our feature string into a qouted lisp symbol. The nameing is important
our module will be compiled to ~cmodule.so~ so the feature symbol *must* be named ~cmodule~,
anything else will not work. Then we get a quoted symbol for the elisp provide function.

#+BEGIN_SRC C :main no :tangle src/cmodule.c
emacs_value Qfeat = env->intern (env, "cmodule");
emacs_value Qprovide = env->intern (env, "provide");
#+END_SRC

#+RESULTS:

We then create an arguements array containing our feature symbol. And have the
Emacs environment call the provides function with our agruement.

#+BEGIN_SRC C :main no :tangle src/cmodule.c
emacs_value pargs[] = { Qfeat };
env->funcall (env, Qprovide, 1, pargs);
#+END_SRC

#+RESULTS:

Next we declare our function and then use Emacs fset to define it. In short we
are telling Emacs that whenever we call ~(cmodule-verion)~ to execute
the ~Fcmodule_version~ C function.

#+BEGIN_SRC C :main no :tangle src/cmodule.c
emacs_value fn = env->make_function (env, 0, 0, Fcmodule_version,
                 "Returns cmodule version", NULL);

emacs_value Qfset = env->intern (env, "fset");
emacs_value Qsym = env->intern (env, "cmodule-version");

emacs_value fargs[] = { Qsym, fn };
env->funcall(env, Qfset, 2, fargs);
return 0;
}
#+END_SRC

** Compiling the module
Create a lib directory to hold our shared libraries.
#+BEGIN_SRC shell :results silent
mkdir lib
#+END_SRC

Now compile ~cmodule.c~ as a shared C library.
#+BEGIN_SRC shell :results silent
gcc -I emacs-25.2/src -fPIC -shared src/cmodule.c -o lib/cmodule.so
#+END_SRC

** Using C module with Emacs.
To test our module we'll start Emacs in batch mode then call our custom function.
#+BEGIN_SRC shell :exports both
emacs -Q -L ./lib -batch --eval "(require 'cmodule)" --eval "(cmodule-version)"
#+END_SRC

#+RESULTS:
0.1

** C summary
Writing a Emacs module in C is straight forward. These are the basic things you
need to create a Emacs module.

1. emacs-module.h
2. plugin_is_GPL_compatibe symbol
3. emacs_module_init entry point
4. Provision module feature within Emacs
5. fset function within Emacs

This C example was put together from [[http://diobla.info/blog-archive/modules-tut.html][diobla.info blog]] . He does a good job of
breaking things down, and has some helper functions for binding and
provisioning.

* Automation
:PROPERTIES:
:HTML_CONTAINER_CLASS: container
:END:
Knowing what we need, we can now create our module in Go.
This whole guide can be run without any manual input using.

#+BEGIN_EXAMPLE emacs-lisp
(org-babel-tangle)
(org-babel-execute-buffer)
#+END_EXAMPLE
